# Development Guide

This guide covers development workflows, best practices, and project conventions for Shipos Kit.

## Version Control

### Git Ignore Configuration

The project uses `.gitignore` to exclude generated files, dependencies, and sensitive data from version control.

#### Dependencies

```gitignore
node_modules
.pnp
.pnp.*
.yarn/*
```

**Why:** Dependencies are managed by pnpm and should be installed via `pnpm install`. Including them in git would bloat the repository and cause conflicts.

#### Build Artifacts

```gitignore
.next/
out/
build
dist
.turbo
*.tsbuildinfo
```

**Why:** Build outputs are generated during development and deployment. They should be rebuilt from source rather than committed.

#### Environment Variables

```gitignore
.env*
!.env.example
!.env.local.example
```

**Why:** Environment files contain sensitive data (API keys, database credentials). Only example files are committed to show required variables.

**Best Practice:**

-   Never commit actual `.env` files
-   Keep `.env.example` updated with all required variables
-   Use placeholder values in example files

#### IDE and System Files

```gitignore
.idea
.DS_Store
```

**Why:** IDE configurations (except VS Code) and system files are user-specific and shouldn't be shared across the team.

**Note:**

-   The `.vscode/` directory is now committed to the repository with recommended settings
-   This ensures consistent editor configuration across the team
-   You can still customize settings locally if needed
-   `.husky/` hooks are committed to ensure consistent pre-commit checks across the team

#### Debug Logs

```gitignore
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*
```

**Why:** Debug logs are generated during errors and contain local environment information.

#### Database Migrations

```gitignore
prisma/migrations
```

**Why:** Migrations are generated by Prisma and should be created through the migration workflow, not manually edited.

**Workflow:**

1. Modify `schema.prisma`
2. Run `pnpm db:migrate:dev`
3. Prisma generates migration files
4. Commit the migration files to git

#### Reference Implementation

```gitignore
/reference
```

**Why:** The `/reference` directory contains the original implementation used as a reference during development. It's not part of the actual project.

## Development Workflow

### Available Scripts

From the root directory:

```bash
# Development
pnpm dev              # Start development server (all packages)
pnpm build            # Build for production
pnpm start            # Start production server

# Code Quality
pnpm lint             # Run Biome linter
pnpm check            # Check linting and formatting
pnpm format           # Format code with Biome
pnpm clean            # Clean build artifacts

# Database
pnpm db:generate      # Generate Prisma client
pnpm db:migrate       # Run database migrations
pnpm db:push          # Push schema changes (dev only)
pnpm db:studio        # Open Prisma Studio GUI
```

### Starting Development

```bash
# Install dependencies
pnpm install

# Generate Prisma client
pnpm db:generate

# Run migrations
pnpm db:migrate

# Start dev server
pnpm dev
```

### Making Changes

1. **Create a feature branch:**

    ```bash
    git checkout -b feature/your-feature-name
    ```

2. **Make your changes:**

    - Edit source files
    - Add tests if applicable
    - Update documentation

3. **Check code quality:**

    ```bash
    pnpm check  # Check linting and formatting
    pnpm format  # Auto-format code
    ```

4. **Test your changes:**

    ```bash
    pnpm dev  # Manual testing
    pnpm test  # Automated tests (when implemented)
    ```

5. **Commit your changes:**
    ```bash
    git add .
    git commit -m "feat: add your feature description"
    ```

### Commit Message Convention

Use conventional commits format:

```
<type>(<scope>): <description>

[optional body]

[optional footer]
```

**Types:**

-   `feat:` - New feature
-   `fix:` - Bug fix
-   `docs:` - Documentation changes
-   `style:` - Code style changes (formatting)
-   `refactor:` - Code refactoring
-   `test:` - Adding or updating tests
-   `chore:` - Maintenance tasks

**Examples:**

```bash
git commit -m "feat(auth): add passkey authentication"
git commit -m "fix(database): resolve migration conflict"
git commit -m "docs(setup): update installation instructions"
```

## Code Quality

### Biome - Linting and Formatting

The project uses [Biome](https://biomejs.dev/) v2.2.2 as a fast, all-in-one toolchain for linting and formatting. Biome replaces ESLint and Prettier with a single, performant tool.

**Configuration:** `biome.json` in the root directory (extended by individual packages)

**Key Features:**

-   Fast linting and formatting (written in Rust)
-   Auto-fix for many issues
-   Import organization
-   EditorConfig support
-   Git integration (respects .gitignore)
-   VCS integration with main branch tracking

**Configuration Structure:**

```json
{
	"formatter": {
		"enabled": true,
		"useEditorconfig": true
	},
	"linter": {
		"enabled": true,
		"rules": {
			/* ... */
		}
	},
	"assist": {
		"actions": {
			"source": { "organizeImports": "on" }
		}
	},
	"vcs": {
		"enabled": true,
		"clientKind": "git",
		"defaultBranch": "main",
		"useIgnoreFile": true
	}
}
```

**Enabled Rules:**

-   Recommended rules enabled by default
-   Unused imports removed automatically (error level with safe fix)
-   Unused function parameters (warning level)
-   Template literal optimization (error level with safe fix)
-   Consistent code style enforcement
-   TypeScript-specific rules

**Style Rules (Error Level):**

-   `noParameterAssign` - Prevent parameter reassignment
-   `useAsConstAssertion` - Enforce `as const` for literal types
-   `useDefaultParameterLast` - Default parameters at end
-   `useEnumInitializers` - Require enum initializers
-   `useSelfClosingElements` - Self-closing JSX elements
-   `useSingleVarDeclarator` - One variable per declaration
-   `useNumberNamespace` - Use Number namespace methods
-   `noInferrableTypes` - Remove redundant type annotations
-   `noUselessElse` - Remove unnecessary else blocks

**Style Rules (Warning Level):**

-   `noNonNullAssertion` - Warn on `!` assertions
-   `useBlockStatements` - Prefer block statements

**Disabled Rules:**

-   `noExplicitAny` - Allows `any` type when necessary
-   `noArrayIndexKey` - Allows array index as React key
-   `noForEach` - Allows `.forEach()` method
-   `useExhaustiveDependencies` - React hook dependencies not enforced
-   `useUniqueElementIds` - Allows duplicate element IDs

**CSS Handling:**

-   CSS formatting and linting are disabled
-   Tailwind classes are not formatted by Biome

**File Exclusions:**

-   `zod/index.ts` - Generated Zod schemas
-   `tailwind-animate.css` - Tailwind animation styles

### Linting

```bash
# Check for issues
pnpm lint

# Fix auto-fixable issues
pnpm lint --fix
```

**What it checks:**

-   Code correctness (unused variables, imports)
-   Code complexity
-   Suspicious patterns
-   Style consistency

### Formatting

```bash
# Check all issues (linting + formatting)
pnpm check

# Format code
pnpm format
```

**Formatting rules:**

-   Uses `.editorconfig` settings
-   Consistent indentation and spacing
-   Automatic semicolon insertion
-   Import organization

**Note:** CSS formatting is disabled in Biome; Tailwind classes are not formatted.

### Type Checking

```bash
# Check TypeScript types
pnpm type-check
```

**What it checks:**

-   Type correctness across all packages
-   Missing type definitions
-   Type compatibility
-   Strict mode compliance

### Pre-commit Hooks

Husky runs lint-staged before commits to check and auto-fix staged files:

**What runs:**

-   Biome check with auto-fix on staged files
-   Applies to: `*.{js,jsx,ts,tsx,json,css}`

**Configuration:**

```json
// package.json
"lint-staged": {
  "*.{js,jsx,ts,tsx,json,css}": "biome check --write --no-errors-on-unmatched"
}
```

**Hook file:**

```bash
# .husky/pre-commit
pnpm lint-staged
```

If checks fail, fix the issues before committing. The hook will automatically format and fix auto-fixable issues.

**Bypass (not recommended):**

```bash
git commit --no-verify -m "message"
```

### IDE Integration

#### VS Code

Install the [Biome extension](https://marketplace.visualstudio.com/items?itemName=biomejs.biome):

```bash
code --install-extension biomejs.biome
```

**Recommended Settings:**

The project includes a `.vscode/settings.json` file with recommended settings:

```json
{
	"editor.defaultFormatter": "biomejs.biome",
	"editor.formatOnSave": true,
	"editor.codeActionsOnSave": {
		"quickfix.biome": "explicit",
		"source.organizeImports.biome": "explicit"
	},
	"typescript.tsdk": "node_modules/typescript/lib",
	"typescript.enablePromptUseWorkspaceTsdk": true,
	"typescript.autoClosingTags": false
}
```

**Settings Explanation:**

-   `editor.defaultFormatter` - Use Biome for formatting
-   `editor.formatOnSave` - Auto-format on save
-   `editor.codeActionsOnSave` - Auto-fix and organize imports
-   `typescript.tsdk` - Use workspace TypeScript version
-   `typescript.enablePromptUseWorkspaceTsdk` - Prompt to use workspace TS
-   `typescript.autoClosingTags` - Disabled to prevent conflicts with Biome formatting

**Note:** The `.vscode/settings.json` file is now committed to the repository to ensure consistent settings across the team. You can customize it locally if needed.

#### Other IDEs

-   [JetBrains IDEs](https://biomejs.dev/guides/integrate-in-editor/#jetbrains-ides)
-   [Neovim](https://biomejs.dev/guides/integrate-in-editor/#neovim)
-   [Sublime Text](https://biomejs.dev/guides/integrate-in-editor/#sublime-text)

## Environment Variables

### Required Variables

```bash
# Database
DATABASE_URL=postgresql://user:password@localhost:5432/shipos

# Authentication
BETTER_AUTH_SECRET=your-secret-key
BETTER_AUTH_URL=http://localhost:3000
```

### Optional Variables

```bash
# OAuth Providers
GOOGLE_CLIENT_ID=your-google-client-id
GOOGLE_CLIENT_SECRET=your-google-client-secret
GITHUB_CLIENT_ID=your-github-client-id
GITHUB_CLIENT_SECRET=your-github-client-secret

# Email Provider
RESEND_API_KEY=your-resend-api-key

# Storage
AWS_ACCESS_KEY_ID=your-access-key
AWS_SECRET_ACCESS_KEY=your-secret-key
AWS_REGION=us-east-1
NEXT_PUBLIC_AVATARS_BUCKET_NAME=avatars

# Payments
STRIPE_SECRET_KEY=sk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...
PAYMENT_PROVIDER=stripe

# AI
OPENAI_API_KEY=sk-...
```

### Managing Environment Variables

1. **Local Development:**

    - Copy `.env.example` to `.env`
    - Fill in your local values
    - Never commit `.env`

2. **Team Sharing:**

    - Update `.env.example` when adding new variables
    - Document required vs optional variables
    - Use placeholder values

3. **Production:**
    - Set environment variables in your hosting platform
    - Use secure secret management
    - Rotate secrets regularly

## Database Development

### Schema Changes

1. **Modify schema:**

    ```prisma
    // packages/database/prisma/schema.prisma
    model User {
      id    String @id @default(cuid())
      name  String
      email String @unique
      // Add new field
      phone String?
    }
    ```

2. **Create migration:**

    ```bash
    pnpm db:migrate:dev
    # Name: add_user_phone_field
    ```

3. **Generate client:**

    ```bash
    pnpm db:generate
    ```

4. **Commit migration:**
    ```bash
    git add packages/database/prisma/schema.prisma
    git add packages/database/prisma/migrations
    git commit -m "feat(database): add phone field to user"
    ```

### Database Reset

**Warning:** This deletes all data!

```bash
pnpm db:reset
```

Use this when:

-   Development database is corrupted
-   Need to start fresh
-   Testing migration from scratch

## Package Development

### Creating a New Package

1. **Create package directory:**

    ```bash
    mkdir -p packages/new-package
    cd packages/new-package
    ```

2. **Create package.json:**

    ```json
    {
    	"name": "@shipos/new-package",
    	"version": "0.0.0",
    	"private": true,
    	"exports": {
    		".": "./index.ts"
    	},
    	"dependencies": {}
    }
    ```

3. **Create tsconfig.json:**

    ```json
    {
    	"extends": "../../tooling/typescript/base.json",
    	"compilerOptions": {
    		"outDir": "dist"
    	},
    	"include": ["**/*.ts"],
    	"exclude": ["node_modules", "dist"]
    }
    ```

4. **Create index.ts:**

    ```typescript
    export function myFunction() {
    	// Implementation
    }
    ```

5. **Install in workspace:**
    ```bash
    cd ../..
    pnpm install
    ```

### Using Workspace Packages

```typescript
// Import from workspace package
import { myFunction } from "@shipos/new-package";
```

## Testing

### Manual Testing

```bash
# Start dev server
pnpm dev

# Open browser
open http://localhost:3000
```

### Automated Testing (Coming Soon)

```bash
# Run unit tests
pnpm test

# Run E2E tests
pnpm test:e2e

# Run tests in watch mode
pnpm test:watch
```

## Debugging

### Server-Side Debugging

Add console.log or use the logger:

```typescript
import { logger } from "@shipos/logs";

logger.debug("Debug info", { userId, data });
logger.info("Operation completed", { result });
logger.error("Operation failed", error, { context });
```

### Client-Side Debugging

Use browser DevTools:

-   Console for logs
-   Network tab for API calls
-   React DevTools for component inspection

### Database Debugging

Use Prisma Studio:

```bash
pnpm db:studio
```

Opens GUI at http://localhost:5555

## Performance Monitoring

### Development

Monitor in browser DevTools:

-   Performance tab
-   Lighthouse audit
-   Network waterfall

### Production

Consider adding:

-   Vercel Analytics
-   Sentry for error tracking
-   LogRocket for session replay

## Troubleshooting

### Port Already in Use

```bash
# Kill process on port 3000
lsof -ti:3000 | xargs kill -9

# Or use different port
PORT=3001 pnpm dev
```

### TypeScript Errors

```bash
# Regenerate types
pnpm db:generate
pnpm install
```

### Build Errors

```bash
# Clean build cache
rm -rf .next .turbo node_modules
pnpm install
pnpm build
```

### Database Connection Issues

```bash
# Check PostgreSQL is running
brew services list  # macOS
sudo systemctl status postgresql  # Linux

# Test connection
psql $DATABASE_URL
```

## Best Practices

### Code Organization

-   Keep files focused and modular
-   Extract reusable logic into packages
-   Use TypeScript for type safety
-   Write self-documenting code

### Performance

-   Use React Server Components by default
-   Add `'use client'` only when needed
-   Optimize images with Next.js Image
-   Implement proper loading states

### Security

-   Never commit secrets
-   Validate all user input
-   Use parameterized queries
-   Implement proper authentication checks

### Documentation

-   Update docs when changing APIs
-   Add JSDoc comments for complex functions
-   Keep README files current
-   Document breaking changes

## Next Steps

-   [Setup Guide](./setup.md) - Initial project setup
-   [Configuration](./configuration.md) - Configure features
-   [Authentication](./authentication.md) - Auth system
-   [Database](./database.md) - Database schema and queries
